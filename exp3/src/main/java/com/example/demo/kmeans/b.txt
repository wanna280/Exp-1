package com.example.demo.kmeans;

import com.example.demo.point.Point;
import com.example.demo.point.PointList;
import com.example.demo.utils.FileOperate;
import com.example.demo.utils.GetRandom;
import com.example.demo.utils.TransForm;

import java.util.ArrayList;

public class KMeans {
    public static void KMeans(int K, Double[] x, Double[] y) {
        PointList[] pointLists = new PointList[K];  //存放聚类后的结果,分成K类
        Point[] points = new Point[K];  //聚类的中心点
        Integer[] random = GetRandom.GetRandom(K);   //生成K个不同的随机数
        Double[][] disList = new Double[K][x.length];   //求出距离列表（矩阵）


        for (int i = 0; i < K; i++) {  //初始化聚类结果列表为空
            pointLists[i] = new PointList();
        }

        for (int i = 0; i < K; i++) {  //生成聚类的中心点
            points[i] = new Point();  //创建空点，并向其中加入值
            points[i].SetXi(0, x[random[i]]);
            points[i].SetXi(1, y[random[i]]);
            pointLists[i].points.add(points[i]);   //向列表中添加中心点
        }


        for (int j = 0; j < K; j++) {  //遍历x的每个元素，求出距离矩阵
            for (int i = 0; i < x.length; i++) {
                Point point = new Point(x[i], y[i]);
                double dis = TransForm.GetDistance(points[j], point);  //求距离数组
                disList[j][i] = dis;  //将其加入距离矩阵当中
            }
        }

        for (int i = 0; i < disList[0].length; i++) {
            if (!TransForm.Exists(i, random)) {   //如果不是聚类的中心点
                double[] arr = new double[K];  //得到每一行的数据
                for (int j = 0; j < K; j++) {
                    arr[j] = disList[j][i];
                }
                for (int j = 0; j < K; j++) {   //如果是最小值，将其index对应的点放入聚类结果列表
                    if (arr[j] == TransForm.GetMin(arr)) {
                        pointLists[j].points.add(new Point(x[i], y[i]));
                        break;
                    }
                }
            }
        }
        for (int i = 0; i < K; i++) {
            System.out.println(pointLists[i].points.size());
        }
        System.out.println();
    }

    public static void KMeans1(int K, Double[][] x, int dim, int num) {
        PointList[] pointLists = new PointList[K];  //存放聚类后的结果,分成K类
        Point[] points = new Point[K];  //聚类的中心点
        Integer[] random = GetRandom.GetRandom(K);   //生成K个不同的随机数
        Double[][] disList = new Double[K][num];   //存放距离矩阵
        ArrayList<Point[]> center = new ArrayList<>();   //存放每次执行的聚类中心
        ArrayList<Point[]> lastCenter = new ArrayList<>();   //保存最后训练好的类中心点
        ArrayList<Point[]> maxDistance = new ArrayList<>();  //保存距离类中心最远的点

        for (int i = 0; i < K; i++) {  //生成聚类的中心点
            pointLists[i] = new PointList();   //初始化聚类的各个类别为空
            points[i] = new Point();  //创建空点，并向其中加入值
            for (int j = 0; j < dim; j++) {    //中心点的各个维度坐标
                points[i].SetXi(j, x[j][random[i]]);  //设置初始中心点的各维度坐标
            }
            pointLists[i].points.add(points[i]);   //向聚类的类列表中添加中心点
        }

        for (int j = 0; j < K; j++) {
            for (int i = 0; i < num; i++) {
                Point point = new Point();
                for (int k = 0; k < dim; k++) {   //将多个纬度的值的转换为Point
                    point.SetXi(k, x[k][i]);
                }
                double dis = TransForm.GetDistance(points[j], point);  //求距离，并更新距离矩阵
                disList[j][i] = dis;
            }
        }

        for (int i = 0; i < disList[0].length; i++) {
            if (!TransForm.Exists(i, random)) {   //如果不是聚类的中心点
                double[] arr = new double[K];  //得到每一行的数据
                for (int j = 0; j < K; j++) {
                    arr[j] = disList[j][i];
                }
                for (int j = 0; j < K; j++) {   //如果是最小值，将其index对应的点放入聚类结果列表
                    if (arr[j] == TransForm.GetMin(arr)) {
                        Point point = new Point();
                        for (int k = 0; k < dim; k++) {
                            point.SetXi(k, x[k][i]);
                        }
                        pointLists[j].points.add(point);
                        break;
                    }
                }
            }
        }
        for (int i = 0; i < K; i++) {  //打印第一次生成的随机中心点
            System.out.print(pointLists[i].points.size() + " ");
        }
        System.out.println();
        center.add(points);  //加入一开始使用随机数随机生成的中心

        int t = 0;
        while (t < 20) {  //循环20次
            Point[] points1 = new Point[K];    //存放聚类的中心点
            for (int i = 0; i < K; i++) {
                points1[i] = new Point();    //重新生成聚类的质心
                double[] sum = new double[dim];  //求和，用来后面求质心
                for (int k = 0; k < dim; k++) {  //求每个维度坐标之和，并将其补充到质心点当中去
                    for (int j = 0; j < pointLists[i].points.size(); j++) {
                        sum[k] += pointLists[i].points.get(j).GetXi(k);
                    }
                    points1[i].SetXi(k, sum[k] / pointLists[i].points.size());  //设置每个质心的每个坐标
                }
            }
            //System.out.println(pointLists[0].points.size());

            Double[][] disList1 = new Double[K][num];  //重新定义一个新的距离矩阵
            for (int i = 0; i < K; i++) {   //把距离矩阵全部用0去初始化
                for (int j = 0; j < num; j++) {
                    disList1[i][j] = 0.0;
                }

            }
            for (int j = 0; j < K; j++) {    //求出点与点之间的距离矩阵
                for (int i = 0; i < num; i++) {
                    Point point = new Point();
                    for (int k = 0; k < dim; k++) {   //将多个维度的值的转换为Point
                        point.SetXi(k, x[k][i]);
                    }
                    double dis = TransForm.GetDistance(points1[j], point);  //求距离，并更新距离矩阵
                    disList1[j][i] = dis;
                }
            }
            center.add(points1);

            for (int i = 0; i < K; i++) {   //清空上一次循环生成的列表，并重新初始化为空
                pointLists[i] = null;
                pointLists[i] = new PointList();
            }

            for (int i = 0; i < disList[0].length; i++) {
                double[] arr = new double[K];  //保存每一行的数据，用于后面对行内求最小值
                for (int j = 0; j < K; j++) {   //得到每一行的数据
                    arr[j] = disList1[j][i];
                }
                for (int j = 0; j < K; j++) {   //如果是最小值，将其index对应的点放入聚类结果列表
                    if (arr[j] == TransForm.GetMin(arr)) {  //判断对应的距离是否为最小值，如果是最小值，将其放入对应的类别的列表当中
                        Point point = new Point();
                        for (int k=0;k<dim;k++){
                            point.SetXi(i,x[k][i]);
                        }
                        pointLists[j].points.add(point);
                        break;
                    }
                }
            }
            for (int i = 0; i < K; i++) {   //遍历每一个类别，打印类别的size
                System.out.print(pointLists[i].points.size() + " ");
            }
            System.out.println();
            t += 1;
        }


        /**
         * 用来生成距离类中心最远的点列表
         * 存放在points_max_to_center中
         */
        Point[] points_max_to_center = new Point[K];   //记录距离中心最远的点的集合
        for (int i = 0; i < K; i++) {   //遍历每个类别
            double max = 0;  //记录类别内距离最大的值
            int index = 0;  //找到距离最大的点的索引
            for (int j = 0; j < pointLists[i].points.size(); j++) {  //遍历每个点找到距离最大的点
                double dis = TransForm.GetDistance(pointLists[i].points.get(j), center.get(20)[i]);
                if (max < dis) {
                    max = dis;
                }   //求出最大距离
            }
            for (int j = 0; j < pointLists[i].points.size(); j++) {  //遍历每个点，利用最大距离求出对应的点
                if (max == TransForm.GetDistance(pointLists[i].points.get(j), center.get(20)[i])) {
                    index = j;
                    break;
                }
            }
            points_max_to_center[i] = pointLists[i].points.get(index); //向数组中添加这个距离最大的点
        }

        lastCenter.add(center.get(20));   //将最后的中心点添加入列表，用于后面的打印和导出
        maxDistance.add(points_max_to_center);   //将距离最远的点放入列表，用于后面的打印和导出

//        FileOperate.ExportFile("data_center.csv", center);   //导出类中心变化过程
//        FileOperate.ExportFile("data_lastCenter.csv", lastCenter);  //导出训练好的类中心
//        FileOperate.ExportFile("data_maxDistance.csv", maxDistance);  //导出距离累中心最远的点的坐标

    }
}
